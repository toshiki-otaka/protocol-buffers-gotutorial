package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"strings"

	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	buf, err := ioutil.ReadAll(os.Stdin)
	if err != nil {
		panic(err)
	}

	var req pluginpb.CodeGeneratorRequest
	if err = proto.Unmarshal(buf, &req); err != nil {
		panic(err)
	}

	files := make(map[string]*descriptorpb.FileDescriptorProto)
	for _, f := range req.ProtoFile {
		files[f.GetName()] = f
	}

	var resp pluginpb.CodeGeneratorResponse

	// ロジック
	for _, fname := range req.FileToGenerate {
		f := files[fname]
		var functionStrings []string
		for _, m := range f.MessageType {
			for _, field := range m.Field {
				if *field.Label == descriptorpb.FieldDescriptorProto_LABEL_REPEATED {
					functionStrings = append(functionStrings, fmt.Sprintf(`
func (x *%s) Count() int {
	return len(x.%s)
}`,
						m.GetName(), goCamelCase(field.GetName())))
				}
			}
		}

		path := strings.Split(fname, "/")
		file := strings.Split(path[1], ".")
		filePrefix := file[0]

		goPackageName := strings.Split(f.Options.GetGoPackage(), "/")

		resp.File = append(resp.File, &pluginpb.CodeGeneratorResponse_File{
			Name:    proto.String(fmt.Sprintf("%s/%s_counter.pb.go", goPackageName[1], filePrefix)),
			Content: proto.String(fmt.Sprintf("// Code generated by protoc-gen-counter. DO NOT EDIT.\n\npackage %s\n%s\n", goPackageName[1], strings.Join(functionStrings, "\n"))),
		})
	}

	buf, err = proto.Marshal(&resp)
	if err != nil {
		panic(err)
	}
	_, err = os.Stdout.Write(buf)
	if err != nil {
		panic(err)
	}
}

func goCamelCase(s string) string {
	// Invariant: if the next letter is lower case, it must be converted
	// to upper case.
	// That is, we process a word at a time, where words are marked by _ or
	// upper case letter. Digits are treated as words.
	var b []byte
	for i := 0; i < len(s); i++ {
		c := s[i]
		switch {
		case c == '.' && i+1 < len(s) && isASCIILower(s[i+1]):
			// Skip over '.' in ".{{lowercase}}".
		case c == '.':
			b = append(b, '_') // convert '.' to '_'
		case c == '_' && (i == 0 || s[i-1] == '.'):
			// Convert initial '_' to ensure we start with a capital letter.
			// Do the same for '_' after '.' to match historic behavior.
			b = append(b, 'X') // convert '_' to 'X'
		case c == '_' && i+1 < len(s) && isASCIILower(s[i+1]):
			// Skip over '_' in "_{{lowercase}}".
		case isASCIIDigit(c):
			b = append(b, c)
		default:
			// Assume we have a letter now - if not, it's a bogus identifier.
			// The next word is a sequence of characters that must start upper case.
			if isASCIILower(c) {
				c -= 'a' - 'A' // convert lowercase to uppercase
			}
			b = append(b, c)

			// Accept lower case sequence that follows.
			for ; i+1 < len(s) && isASCIILower(s[i+1]); i++ {
				b = append(b, s[i+1])
			}
		}
	}
	return string(b)
}

func isASCIILower(c byte) bool {
	return 'a' <= c && c <= 'z'
}
func isASCIIUpper(c byte) bool {
	return 'A' <= c && c <= 'Z'
}
func isASCIIDigit(c byte) bool {
	return '0' <= c && c <= '9'
}
